# 跃迁至圈外 · 跳转语句

经过先前对条件判断与条件循环的学习，我们已经可以据此构造出基本的逻辑流程了。不过，仅凭这么点工具似乎仍然不够用。

接下来，我们还将再度深入，了解更进一步的流程控制方法，让整个程序的流程变得完全可控。

------

先来看个简单的问题：

> 如何做到输入 n 个数字，再求出它们的和？

这应该不难，我们先知道```n```是多少，再连续接收```n```次数字，接收一次就累加一次：

```cpp
int n;
cin >> n;						// 先获取 n
int sum = 0;					// 初始化一个存贮累加结果的变量
for (int i = 0; i < n; ++i)		// 循环 n 次
{
    int a;						// 每轮循环都新声明一个变量
    cin >> a;					// 每轮循环都接收一次数字
    sum += a;					// 将接收到的数字累加进 sum
}
cout << sum << endl;			// 输出结果
```

不过，如果不知道```n```这个确切的循环次数，这种程序就不能解决问题了。

再来看一下修改后的问题：

> 如何做到输入若干个数字，当某次输入的数字为 0 时就结束输入，再求出它们的和？

由于输入数字的数量是未知的，我们需要不断地获取输入，这就需要无限循环地执行获取输入与累加的过程。但同时，我们又需要再输入的数字为 0 时结束循环。

仅凭单纯的循环与判断实现这样的逻辑很是麻烦。现在，我们尝试一下更简便的做法：

```cpp
int sum = 0;					// 初始化一个存贮累加结果的变量
for (;;)						// 无限循环
{
    int a;						// 每次循环都新声明一个变量
    cin >> a;					// 每次循环都接受一次数字
    if (a == 0) break;			// 如果 a 为 0，就跳出循环
    else sum += a;				// 如果 a 不为 0，继续累加；这里的 else 其实也是可以不写的
}
cout << sum << endl;			// 输出结果
```

```break``` 用于跳出当前所在的循环体，可以在 ```for```、```while```与```do...while``` 中使用。在这个例子中，我们在一句```if```内使用了 ```break```，使得循环得以在特定条件下主动跳出。

要使用```break```，只需要保证它是在某个可被跳出的语句块内，没有其它限制。下面的例子展示了其跳出循环体的能力：

```cpp
while (10 > 6) break;			// 执行了一次判断，进入循环后立即跳出
do break while (15 < 30);		// 还没来得及执行判断，循环就被跳出
for (;;) break;					// 刚进入无限循环就被跳出
```

------

很多时候，```break``` 被用于跳出**死循环**，或也可以称为**无限循环**。顾名思义，这种循环是无法自发停止的。

要写出一个死循环，只需要保证循环条件始终为真(```true```)就可以了：

```cpp
while (true) ...;				// 一个最经典的 while 死循环
while (2 * 3 == 6) ...;			// 2 * 3 == 6 的结果始终为 true，形成死循环
while (a - 1 < a) ...;			// a - 1 < a 恒成立，结果始终为 true，形成死循环
do ... while (true);			// 一个最经典的 do ... while 死循环
for (;;) ...;					// 一个最经典的 for 死循环，其中的条件可被省略，默认始终为 true
for (;true;) ...;				// 将隐含的条件始终为 true 明确写出来的样子
```

死循环可用于不定量数据的输入、输出与不间断的数据监视、数据处理等。很明显，这类死循环在外界条件发生变化时，便需要使用 ```break``` 结束循环，例如数据全部读写完成、用户发起了停止的指令等。

------

有时候，我们需要在循环不结束的情况下，只结束这一轮的循环，这类需求并不少见。我们来看个具体的问题：

> 请列举 200 以内的素数

素数是什么？只能被这个数本身和 1 整除的大于 1 的自然数就是素数。像 2、3、5、7、23、51 这类就是素数，而像 4、6、10、30 这类很明显可以被其它数字整除的数字就不是素数。

根据以上的概念，我们可以确定基本思路，是将每个数字都拿来试除一遍。只要出现一次余数为 0 的情况，就可以断定它不是素数。

具体的实现如下：

```cpp
bool flags[200];					// 用于存储 200 以内的各数是否为素数的标识
for (int i = 2; i < 200; ++i)		// 从 2 数到 200，逐个检查
{
    flags[i] = true;				// 先假设第 i 个数是素数的标识
    for (int j = 2; j < i; ++j)		// 从 2 数到 i - 1，逐个与 i 试除
    {
        if (i % j == 0)				// 当余数为 0 时，相当于被整除
        {
            flags[i] = false;		// 设置第 i 个数不是素数的标识
            break;					// 结束这一层循环，继续对下一个数的检查
        }
    }
}

for (int i = 2; i < 200; ++i)		// 逐个输出判断结果
  if (flags[i]) cout << "第" << i << "个数是素数" << endl;
```

这个程序先定义了一个很大的数组，用于存储这 200 为数字是否为素数的标识。外围的循环从 2 数到 199，列举每个数字；内围的循环则是从 2 数到这个数字的前一个数字，分别将它们作为除数与这个数字相除。当列举的所有数字部都无法整除它时，就可以断定它是一个素数了。

不过，这个程序还有可以改进的空间。在刚刚的程序中，我们将从 2 到 i - 1 的每个数字都用了一遍，但实际上我们只需要拿素数作除法就可以了：

```cpp
bool flags[200];
for (int i = 2; i < 200; ++i)
{
    flags[i] = true;
    for (int j = 2; j < i; ++j)
    {
        if (!flags[i]) continue;	// 如果不是素数，停止本轮循环，直接进入下一轮循环
        if (i % j == 0)
        {
            flags[i] = false;
            break;
        }
    }
}
```

```continue``` 用于结束其所在循环体的本轮循环。它与 ```break``` 的区别在于，```break``` 会直接结束整个循环，而 ```continue``` 则不会结束整个循环，仅仅是结束这一轮循环而已，下一轮循环会立即开始。

它的使用条件与 ```break``` 也没有太大的出入：

```cpp
while (true) continue;				// 无限循环，并且永远不能被跳出
do continue while (true);			// 上一个无限循环的另一种形式
for (int i = 0; i < 100; ++i)		// 一个只输出奇数的例子
{
    if (i % 2 == 0) continue;		// 如果为偶数，结束本轮循环，下面的语句也就不会被执行
    cout << i << endl;				// 打印当前列举到的数字
}
```

回到刚刚过滤素数的例子。从数学角度来看，要知晓一个数字是否为素数，只需要将其与比此数字小的所有数字相除一遍就可以了，无需连同非素数也来一遍——重复的非素数与其之前的部分素数有公因数，因此只除以一遍这个素数便足矣。

所以，```continue``` 在修改后程序中的作用就很明显了，其实就是判断不为素数为真的情况下，结束此轮循环，避免无用的运算。在执行下一轮循环前，```for``` 语句中的 ```++j``` 会照常执行。

------

也许，```if``` 和 ```else``` 够我们拿来用作判断了，但碰到大批量判断某个变量的各种值时，一个一个地写 ```if``` 和 ```else``` 实在是很费事：

```cpp
if (n == 1) target = "原木";
else if (n == 2) target = "木板";
else if (n == 3) target = "圆石";
else if (n == 4) target = "沙子";
...
```

幸好，C++ 提供了 ```switch```，它可以帮助我们轻松地书写大规模对同一个变量的判断逻辑：

```cpp
switch(n)
{
    case 1:
        target = "原木";
        break;
    case 2:
        target = "木板":
        break;
    case 3:
        target = "圆石";
        break;
    case 4:
        target = "沙子":
        break;
    ...
}
```

```switch``` 后跟一对小括号，其中是欲判断的变量。在这之后的一对花括号内有若干个以 ```case``` 为开头、冒号为末尾的标记，其中 ```case``` 后以空格隔开一个**常量**。```switch``` 语句会执行其中一个 ```case``` 标记后的语句，执行哪一个取决于被判断的变量与其中哪个标识对应的常量相等。从寻到的标记开始，除非遇到 ```break``` 语句，否则将会一直执行到 ```switch``` 语句块的末尾。

它的格式是这样的：

```cpp
switch (<被判断的值>)
{
    case <常量1>:
        <值等于常量1时执行的一系列语句>
    case <常量2>:
        <值等于常量2时执行的一系列语句>
    ...
    default:
        <没有任何常量与给定值相等时执行的逻辑>
}
```



```default``` 用于处理被判断的值不等于 ```switch``` 中任意一个 ```case``` 后跟的变量的情况。一般来讲，我们都应当在 ```switch``` 中写一个 ```default``` 标识，哪怕真的没啥事可做：

```cpp
switch (...)
{
    default:
        // 如果无事可做，最好也留个 default
}
```

为什么非得留个 ```default``` 呢？这算是一种良好的习惯，它可以帮助后来阅读与修改这个程序的人（包括你自己）完整理解这段选择逻辑的行为，不至于出现错误的改正。用大白话讲，如果没加 ```default ``` 又被后来者看到了，他很可能会补上一个 ```default```，并添加一些违背原作者意愿的逻辑，得不偿失。

```break``` 不光可用于跳出循环体，也可以用于跳出 ```switch``` 语句块。有些人会想当然地以为，从一个 ```case``` 开始，执行到下一个 ```case``` 时，会自动跳出 ```switch```，实际上却不是这样：

```cpp
switch(3)
{
    default: 		// 从这里开始还算正常
        cout << "default" << endl;
    case 1:			// 到这里它是不会停的！
        cout << 1 << endl;
    case 2:			// 到这里仍然不会停！
        cout << 2 << endl;
}
```

这段程序执行后，三行 ```cout``` 都会被执行！所以，要想各个 ```case``` 互不干扰，一定要记得在各段 ```case``` 的末尾加 ```break```。

这种特性并非一无是处。如果我们需要整合一批 ```case``` 执行同一批逻辑，使用刚刚所谓不停执行的特性会方便许多：

```cpp
switch(n)
{
    case 1:
    case 3:
    case 5:
		cout << "n 为 1, 3 或 5" << endl;
        break;									// 别忘了！
    case 2:
    case 4:
    default:
        cout << "n 为 2, 4 或其它值" << endl;
        // 如果这段 case 在 switch 语句块的末尾，break 写不写都一样
        break;
}
```

------

至此，我们便掌握了一切在 C++ 中实现结构化程序逻辑的基本工具。它们是程序中最基本的组成部分，熟练使用它们，可以帮助你构筑无限的可能！

